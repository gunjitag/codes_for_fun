########################################################
########################################################
                    #Project Euler#
########################################################
########################################################

####################################################################################################
#Problem 1: Multiples of 3 and 5
# If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. 
#The sum of these multiples is 23.
# Find the sum of all the multiples of 3 or 5 below 1000.
####################################################################################################

#Clear the environment 
rm(list= ls())


#Put in the upper limit
upper_limit <- 999


#Find all numbers that are multiples of 3 and 5 below the upper limit and add them to make the required sum

#Method 1: MAKE A FUNCTION AND APPLY IT TO THE VECTOR
#Write a function that returns number if divisible by 3 or 5 and 0 otherwise
multiple_3or5 <- function(x){
  y <- if(x%%3 == 0) x else if(x%%5 == 0) x else 0
  y
}

#Apply function to each element of a vector from 1 to upperlimit, and sum
sum(sapply(seq(1:upper_limit), multiple_3or5))


#Method 2: DIRECTLY APPLY THE CONDITION
seq <- seq(1:upper_limit)
sum(seq[seq %% 3 == 0 | seq %% 5 == 0])

###################################################################################################
#Problem 2: Even Fibbonacci Numbers
# Each new term in the Fibonacci sequence is generated by adding the previous two terms. 
#By starting with 1 and 2, the first 10 terms will be:
#   1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
# By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
####################################################################################################

#Clear the environment 
rm(list= ls())

#Put in the limit
limit <- 4000000

#Create fibbonaci_seq
fibbonaci_seq <- c()
fibbonaci_seq[1] <- 1
fibbonaci_seq[2] <- 2
i <- 3

while (fibbonaci_seq[i-1] + fibbonaci_seq[i-2] <= limit) {
  fibbonaci_seq[i] = fibbonaci_seq[i-1] + fibbonaci_seq[i-2]
  i <- i +1
}

#METHOD 1: MAKE A FUNCTION AND APPLY IT TO THE VECTOR
#Is the element a multiple of 2
multiple_q <- function(x,y){
  z <- if(x%%y == 0) x else 0
  z
}

#Get the sum
sum(sapply(fibbonaci_seq,multiple_q,y=2))

#METHOD 2: USE CONDITION DIRECTLY
#Way to do it without the function
sum(fibbonaci_seq[fibbonaci_seq %% 2 == 0])



####################################################################################################
# Problem 4: A palindromic number reads the same both ways. 
#The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 ?? 99.
# Find the largest palindrome made from the product of two 3-digit numbers.
####################################################################################################

#Clear the environment 
rm(list = ls())

#Write a fuction that reverses a number and checks Palindrome 
return_palindomes <- function(x) {
  x_val <- x
  rev_x <- 0
  while(x>0) {
  y <- x%%10
  rev_x = rev_x*10 + y
  x <- floor(x/10)
  }
  if(x_val == rev_x) x_val else 0
}

#Get the matrix of products of all 3 digit numbers
row_seq <- matrix(100:999, nrow = 1)
col_seq <- matrix(100:999, ncol = 1)
products_3digit <- col_seq %*% row_seq

#Consider only those products greater than 900000 and narrow the search of Palindomes (last digit must be 9)
products_1 <- products_3digit[products_3digit > 900000]
products1_check <- products_1[products_1 %% 10 == 9]

#Return the maximum Palindrome if any
max(sapply(products1_check, return_palindomes))


####################################################################################################
# Problem 5: 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
# What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
####################################################################################################

#Clear the environment 
rm(list = ls())

#The number must atleast be a product of all prime numbers until 20:
x <- 2*3*5*7*11*13*17*19


#Moving up from this number, write a program to see whether the number is divisible by all numbers
#Note that if the number is divisible by x, it is divisible by all its factors, so we only need to check
#for a range number/2 to number 
#Also note that the number needs to be divisible by 20, so we start from a number divisible by 20
#and add 20 each time 

x <- ceiling(x/20)*20

#Create a vector for the numbers to be checked:
vec_check <- seq(11,20)

repeat {
  check <- max(x%%vec_check)
  if(check == 0) {
    print(x)
    break
  }
  else {
    x = x + 20
  }
}

##This does the job but takes a bit of time 


####################################################################################################
# Problem 6: Sum square difference
# The sum of the squares of the first ten natural numbers is :1^2+2^2+...+10^2=385
# The square of the sum of the first ten natural numbers is: (1+2+...+10)^2=55^2=3025
# Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025???385=2640.
# Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
####################################################################################################

#Clear the environment 
rm(list = ls())

#Enter the range of numbers required
lower_limit <- 1
upper_limit <- 100

vec_seq <- seq(lower_limit,upper_limit)

#Find the sum of squares
sum_of_squares <- sum(vec_seq*vec_seq)

#Find the square of sum
sum_vec  <- sum(vec_seq)
square_of_sum <- sum_vec*sum_vec

#Find difference in sum
diff <- square_of_sum - sum_of_squares



